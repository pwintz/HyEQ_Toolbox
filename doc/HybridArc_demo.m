%% Hybrid Arcs and Solutions
% In this tutorial, we show how to create and solve a hybrid system 
% using the |HybridSystem| class. For a brief introduction to hybrid systems, 
% see 
% <matlab:hybrid.internal.openHelp('intro_to_hybrid_systems') here>.
 
bb_system = hybrid.examples.BouncingBall();

x0 = [10, 0];
tspan = [0, 20];
jspan = [0, 30];
config = HybridSolverConfig('refine', 32); % Improves plot smoothness for demo.
sol = bb_system.solve(x0, tspan, jspan, config);
plotFlows(sol); % Display solution

%% Information About Solutions
% 
% The return value of the |solve| method is a |HybridSolution| object that contains 
% information about the solution.
sol

%% 
% The |HybridSolution| class is a subclass of the |HybridArc| class and inherits
% the following properties:
% * |t|: The continuous time values of the solution's hybrid time domain.
% * |j|: The discrete time values of the solution's hybrid time domain.
% * |x|: The state vector of the hybrid arc at each time step.
% * |jump_count|: the number of discrete jumps.
% * |jump_times|: the continuous times when each jump occured.
% * |is_jump_end| Column vector containing |1| at each entry where a jump end and |0| otherwise.
% * |is_jump_start| Column vector containing |1| at each entry where a jump starts and |0| otherwise.
% * |jump_end_indices| Column vector containing each index in t, j, and x arrays
% * |jump_start_indices| Column vector containing each index in t, j, and x arrays
% * |flow_lengths|: the durations of each interval of flow.
% * |shortest_flow_length|: the length of the shortest interval of flow.
% * |total_flow_length|: the length of the entire solution in continuous time.
% 
% |HybridSolution| objects have the following additional properties:
%
% * |x0|: The initial state of the solution.
% * |xf|: The final state of the solution.
% * |termination_cause|: the reason that the solution terminated. 
%
% The possible values for |termination_cause| are 
% 
% * |STATE_IS_INFINITE|
% * |STATE_IS_NAN|
% * |STATE_NOT_IN_C_UNION_D|  
% * |T_REACHED_END_OF_TSPAN| 
% * |J_REACHED_END_OF_JSPAN|
% * |CANCELED|

%% Modifying Hybrid Arcs
% Often, after calculating a solution to a hybrid system, we wish to manipulate 
% the resulting data, such as evaluating a function along the solution, removing 
% some of the components, or truncating the hybrid domain. Several functions 
% to this end are included in the |HybridArc| class (|HybridSolution| is a subclass 
% of |HybridArc|, so the solutions generated by |HybridSystem.solve| are |HybridArc| 
% objects). 
% In particular, the functions are |select|, |transform|, |restrictT| and
% |restrictJ|, |interpolateToArray|, |interpolateToHybridArc|. 
% See |<matlab:doc('HybridArc') doc('HybridArc')>| for details.

hybrid_arc = sol.select(1);                   % Pick the 1st component.
hybrid_arc = hybrid_arc.transform(@(x) -x);   % Negate the value.
hybrid_arc = hybrid_arc.restrictT([1.5, 12]); % Truncate to t-values between 4.5 and 7.
hybrid_arc = hybrid_arc.restrictJ([2, inf]);  % Truncate to j-values >= 2.

% Plot hybrid arcs
clf
hpb = HybridPlotBuilder();
hpb.color('black').legend('Original').plotFlows(sol.select(1));
hold on
hpb.color('red').legend('Modified').plotFlows(hybrid_arc)

%% 
% *Example:* Suppose we want to compute the total energy
% of the bouncing ball: 
%
% $$E(x) = \gamma x_1 + \frac{1}{2} x_2^2.$$
%
% We can map the |HybridArc| object |sol| to a new |HybridArc| with the
% |transform| function. (Note that the state dimension before ($n=2$) and after ($n=1$)
% are not the same.)
% 
clf
energy_fnc = @(x) bb_system.gamma*x(1) + 0.5*x(2)^2;
plotFlows(sol.transform(energy_fnc))
title('Total Energy of Bouncing Ball')
ylabel('Energy')

%% Interpolation
% There are two functions for interpolating th hybrid arcs to different time
% grids. 
% The function |interpolateToArray| creates (as the name suggests) an
% array of values |x_interp| of $x$ at the $t$ locations given as an array |t_grid|.

grid = linspace(1.2, 5.5, 10);
sol_x1 = sol.select(1); % Select only first component.
x1_interp = sol_x1.interpolateToArray(grid);

clf
% Plot original Hybrid Arc
hpb = HybridPlotBuilder().color('black').label('$x_1$')...
    .legend('Hybrid Arc')...
    .plotFlows(sol_x1.restrictT([0, 6]));
hold on

% Plot interpolated array.
interp_plt = plot(grid, x1_interp, 'red*-');
hpb.addLegendEntry(interp_plt, 'Interpolated Array');

% Plot interpolation grid.
grid_plt = plot(grid, 0*grid, 'r|');
hpb.addLegendEntry(grid_plt, 'Interpolation Grid');


%% 
% An evenly spaced interpolation grid can also be automatically generated by
% passing a single natural number equal to |2| or greater. 
% In this case, it can be useful to use two output arguments, where the first is
% set to the interpolated values of $x$ and the second is set to the values of the
% interpolation grid for $t$.

n_interp = 300;
sol_x1 = sol.select(1); % Select only first component.
[x_interp, t_interp] = sol_x1.interpolateToArray(n_interp);
clf
plot(t_interp, x_interp, '.-')

%% 
% Alternatively, you can also use interpolation to create a new |HybridArc| object. 
% The resulting hybrid arc interpolates the value of $x$ at each given point in
% time, but also includes the values at jumps (both before and after) so that
% the hybrid time domain is preserved (at least within the range of the given
% time grid---the range can be restricted).

grid = linspace(0, 1, 40);
t_grid_even_space = sol.t(end) * grid;
t_grid_increasing_space = sol.t(end)*grid.^2;
t_grid_decreasing_space = sol.t(end)*(1 - (1 - grid).^2);
% Create interpolated array.
sol_x1 = sol.select(1); % Select only first component.
sol_x1_interp_even = sol_x1.interpolateToHybridArc(t_grid_even_space);
sol_x1_interp_inc = sol_x1.interpolateToHybridArc(t_grid_increasing_space);
sol_x1_interp_dec = sol_x1.interpolateToHybridArc(t_grid_decreasing_space);

% Plot hybrid arcs.
clf
hpb = HybridPlotBuilder();

% Plot original hybrid arcs.
hpb.color('black').flowMarker('').jumpMarker('').legend('Original');
subplot(3, 1, 1); hpb.plotFlows(sol_x1); hold on
subplot(3, 1, 2); hpb.plotFlows(sol_x1); hold on
subplot(3, 1, 3); hpb.plotFlows(sol_x1); hold on

% Plot interpolated arcs.
hpb.color('red').jumpMarker('*').flowMarker('.');
subplot(3, 1, 1); hpb.legend('Interpolated (Even Space)').plotFlows(sol_x1_interp_even)
subplot(3, 1, 2); hpb.legend('Interpolated (Increasing Space)').plotFlows(sol_x1_interp_inc)
subplot(3, 1, 3); hpb.legend('Interpolated (Decreasing Space)').plotFlows(sol_x1_interp_dec)

%%
% For both interpolation functions, |interpolateToArray| and
% |interpolateToHybridArc| you can
% 
% * Pass a single integer instead of a time grid. The function then generates an
% evenly spaced time grid with the given number of points (in the case of
% |interpolateToHybridArc|, though, the number of output time steps will be
% generally be higher due to the time steps added at jumps!)
% * The interpolation method can be modified by using the name-value arguments
% |'InterpMethod'| followed by the desired interpolation method given as a
% string, such as |'previous'|, |'linear'|, etc. 
% See <matlab:doc('interp1') |interp1|> for a full list.
% 

%%
% The |interpolateToArray| function also has an option to set how to handle
% interpolation points that occur exactly at a jump time. 
% In such cases, there are two or more values of $x$ at a single value of $t$,
% so standard interpolation is not well defined. 
% The default behavior for |interpolateToArray| is to use the mean value of
% before and after (possibly multiple) jumps.

% In cases where an interpolation point in |t_grid| aligns with one of the jump
% times, the resulting array can be configured

jump_time = 2;
t = [0; jump_time; jump_time; 4];
j = [0;         0;         1; 1];
x = [3;         3;         5; 5];
harc = HybridArc(t, j, x);

% Grid for interpolation.
t_grid = [0; 1.5; jump_time; 3; 4];

x_interp = harc.interpolateToArray(t_grid);
x_interp'


% plot
clf
HybridPlotBuilder().color('black').plotFlows(harc)
hold on
plot(t_grid, x_interp, 'redo-')

%%
% Setting the output 

x_interp = harc.interpolateToArray(t_grid, 'ValueAtJump', 'nan');
x_interp'

% plot
clf
HybridPlotBuilder().color('black').plotFlows(harc)
hold on
plot(t_grid, x_interp, 'redo-')

%% 

% Note that we need to use the 't_interp' output because x_interp may have added
% rows.
[x_interp, t_interp] = harc.interpolateToArray(t_grid, 'ValueAtJump', 'both');
x_interp'

%%

% plot
clf
HybridPlotBuilder().color('black').plotFlows(harc)
hold on
plot(t_interp, x_interp, 'redo-')
%% 
x_interp_start = harc.interpolateToArray(t_grid, 'ValueAtJump', 'start');
x_interp_start'

%%
x_interp_end = harc.interpolateToArray(t_grid, 'ValueAtJump', 'end');
x_interp_end'

%%
% plot
clf
HybridPlotBuilder().color('black').plotFlows(harc)
hold on
plot(t_grid, x_interp_start, '-', 'Color', 'red', 'Marker', 'd')
plot(t_grid, x_interp_end, '-', 'Color', 'blue', 'Marker', 'o')


%% Creating |HybridArc|s from arrays
% You can also construct a |HybridArc| directly from the values of |t|, |j|, and
% |x| as follows:
t = linspace(0, 10, 100)'; % Must be a column vector
j = zeros(100, 1); 
x = t.^2;
hybrid_arc = HybridArc(t, j, x)
